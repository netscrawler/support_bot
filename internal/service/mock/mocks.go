// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package service_mock

import (
	"context"
	"iter"
	"support_bot/internal/models"

	mock "github.com/stretchr/testify/mock"
)

// NewMockChatProvider creates a new instance of MockChatProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChatProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockChatProvider {
	mock := &MockChatProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockChatProvider is an autogenerated mock type for the ChatProvider type
type MockChatProvider struct {
	mock.Mock
}

type MockChatProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *MockChatProvider) EXPECT() *MockChatProvider_Expecter {
	return &MockChatProvider_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockChatProvider
func (_mock *MockChatProvider) Create(ctx context.Context, chat *models.Chat) error {
	ret := _mock.Called(ctx, chat)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Chat) error); ok {
		r0 = returnFunc(ctx, chat)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatProvider_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockChatProvider_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - chat *models.Chat
func (_e *MockChatProvider_Expecter) Create(ctx interface{}, chat interface{}) *MockChatProvider_Create_Call {
	return &MockChatProvider_Create_Call{Call: _e.mock.On("Create", ctx, chat)}
}

func (_c *MockChatProvider_Create_Call) Run(run func(ctx context.Context, chat *models.Chat)) *MockChatProvider_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.Chat
		if args[1] != nil {
			arg1 = args[1].(*models.Chat)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatProvider_Create_Call) Return(err error) *MockChatProvider_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatProvider_Create_Call) RunAndReturn(run func(ctx context.Context, chat *models.Chat) error) *MockChatProvider_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockChatProvider
func (_mock *MockChatProvider) Delete(ctx context.Context, chatID int64) error {
	ret := _mock.Called(ctx, chatID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, chatID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatProvider_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockChatProvider_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - chatID int64
func (_e *MockChatProvider_Expecter) Delete(ctx interface{}, chatID interface{}) *MockChatProvider_Delete_Call {
	return &MockChatProvider_Delete_Call{Call: _e.mock.On("Delete", ctx, chatID)}
}

func (_c *MockChatProvider_Delete_Call) Run(run func(ctx context.Context, chatID int64)) *MockChatProvider_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatProvider_Delete_Call) Return(err error) *MockChatProvider_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatProvider_Delete_Call) RunAndReturn(run func(ctx context.Context, chatID int64) error) *MockChatProvider_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// GetAll provides a mock function for the type MockChatProvider
func (_mock *MockChatProvider) GetAll(ctx context.Context) ([]models.Chat, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAll")
	}

	var r0 []models.Chat
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.Chat, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.Chat); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Chat)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChatProvider_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockChatProvider_GetAll_Call struct {
	*mock.Call
}

// GetAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockChatProvider_Expecter) GetAll(ctx interface{}) *MockChatProvider_GetAll_Call {
	return &MockChatProvider_GetAll_Call{Call: _e.mock.On("GetAll", ctx)}
}

func (_c *MockChatProvider_GetAll_Call) Run(run func(ctx context.Context)) *MockChatProvider_GetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockChatProvider_GetAll_Call) Return(chats []models.Chat, err error) *MockChatProvider_GetAll_Call {
	_c.Call.Return(chats, err)
	return _c
}

func (_c *MockChatProvider_GetAll_Call) RunAndReturn(run func(ctx context.Context) ([]models.Chat, error)) *MockChatProvider_GetAll_Call {
	_c.Call.Return(run)
	return _c
}

// GetByTitle provides a mock function for the type MockChatProvider
func (_mock *MockChatProvider) GetByTitle(ctx context.Context, title string) (*models.Chat, error) {
	ret := _mock.Called(ctx, title)

	if len(ret) == 0 {
		panic("no return value specified for GetByTitle")
	}

	var r0 *models.Chat
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.Chat, error)); ok {
		return returnFunc(ctx, title)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.Chat); ok {
		r0 = returnFunc(ctx, title)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Chat)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, title)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChatProvider_GetByTitle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByTitle'
type MockChatProvider_GetByTitle_Call struct {
	*mock.Call
}

// GetByTitle is a helper method to define mock.On call
//   - ctx context.Context
//   - title string
func (_e *MockChatProvider_Expecter) GetByTitle(ctx interface{}, title interface{}) *MockChatProvider_GetByTitle_Call {
	return &MockChatProvider_GetByTitle_Call{Call: _e.mock.On("GetByTitle", ctx, title)}
}

func (_c *MockChatProvider_GetByTitle_Call) Run(run func(ctx context.Context, title string)) *MockChatProvider_GetByTitle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatProvider_GetByTitle_Call) Return(chat *models.Chat, err error) *MockChatProvider_GetByTitle_Call {
	_c.Call.Return(chat, err)
	return _c
}

func (_c *MockChatProvider_GetByTitle_Call) RunAndReturn(run func(ctx context.Context, title string) (*models.Chat, error)) *MockChatProvider_GetByTitle_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReportGetter creates a new instance of MockReportGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReportGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReportGetter {
	mock := &MockReportGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReportGetter is an autogenerated mock type for the ReportGetter type
type MockReportGetter struct {
	mock.Mock
}

type MockReportGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReportGetter) EXPECT() *MockReportGetter_Expecter {
	return &MockReportGetter_Expecter{mock: &_m.Mock}
}

// GetAllActive provides a mock function for the type MockReportGetter
func (_mock *MockReportGetter) GetAllActive(ctx context.Context) ([]models.Report, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllActive")
	}

	var r0 []models.Report
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.Report, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.Report); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Report)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReportGetter_GetAllActive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllActive'
type MockReportGetter_GetAllActive_Call struct {
	*mock.Call
}

// GetAllActive is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockReportGetter_Expecter) GetAllActive(ctx interface{}) *MockReportGetter_GetAllActive_Call {
	return &MockReportGetter_GetAllActive_Call{Call: _e.mock.On("GetAllActive", ctx)}
}

func (_c *MockReportGetter_GetAllActive_Call) Run(run func(ctx context.Context)) *MockReportGetter_GetAllActive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockReportGetter_GetAllActive_Call) Return(reports []models.Report, err error) *MockReportGetter_GetAllActive_Call {
	_c.Call.Return(reports, err)
	return _c
}

func (_c *MockReportGetter_GetAllActive_Call) RunAndReturn(run func(ctx context.Context) ([]models.Report, error)) *MockReportGetter_GetAllActive_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetabaseDataGetter creates a new instance of MockMetabaseDataGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetabaseDataGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetabaseDataGetter {
	mock := &MockMetabaseDataGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetabaseDataGetter is an autogenerated mock type for the MetabaseDataGetter type
type MockMetabaseDataGetter struct {
	mock.Mock
}

type MockMetabaseDataGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetabaseDataGetter) EXPECT() *MockMetabaseDataGetter_Expecter {
	return &MockMetabaseDataGetter_Expecter{mock: &_m.Mock}
}

// GetDataIter provides a mock function for the type MockMetabaseDataGetter
func (_mock *MockMetabaseDataGetter) GetDataIter(ctx context.Context, cardUUID string) (iter.Seq[map[string]any], error) {
	ret := _mock.Called(ctx, cardUUID)

	if len(ret) == 0 {
		panic("no return value specified for GetDataIter")
	}

	var r0 iter.Seq[map[string]any]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (iter.Seq[map[string]any], error)); ok {
		return returnFunc(ctx, cardUUID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) iter.Seq[map[string]any]); ok {
		r0 = returnFunc(ctx, cardUUID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iter.Seq[map[string]any])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, cardUUID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetabaseDataGetter_GetDataIter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDataIter'
type MockMetabaseDataGetter_GetDataIter_Call struct {
	*mock.Call
}

// GetDataIter is a helper method to define mock.On call
//   - ctx context.Context
//   - cardUUID string
func (_e *MockMetabaseDataGetter_Expecter) GetDataIter(ctx interface{}, cardUUID interface{}) *MockMetabaseDataGetter_GetDataIter_Call {
	return &MockMetabaseDataGetter_GetDataIter_Call{Call: _e.mock.On("GetDataIter", ctx, cardUUID)}
}

func (_c *MockMetabaseDataGetter_GetDataIter_Call) Run(run func(ctx context.Context, cardUUID string)) *MockMetabaseDataGetter_GetDataIter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetabaseDataGetter_GetDataIter_Call) Return(seq iter.Seq[map[string]any], err error) *MockMetabaseDataGetter_GetDataIter_Call {
	_c.Call.Return(seq, err)
	return _c
}

func (_c *MockMetabaseDataGetter_GetDataIter_Call) RunAndReturn(run func(ctx context.Context, cardUUID string) (iter.Seq[map[string]any], error)) *MockMetabaseDataGetter_GetDataIter_Call {
	_c.Call.Return(run)
	return _c
}

// GetDataMap provides a mock function for the type MockMetabaseDataGetter
func (_mock *MockMetabaseDataGetter) GetDataMap(ctx context.Context, cardUUID string) ([]map[string]any, error) {
	ret := _mock.Called(ctx, cardUUID)

	if len(ret) == 0 {
		panic("no return value specified for GetDataMap")
	}

	var r0 []map[string]any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]map[string]any, error)); ok {
		return returnFunc(ctx, cardUUID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []map[string]any); ok {
		r0 = returnFunc(ctx, cardUUID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]map[string]any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, cardUUID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetabaseDataGetter_GetDataMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDataMap'
type MockMetabaseDataGetter_GetDataMap_Call struct {
	*mock.Call
}

// GetDataMap is a helper method to define mock.On call
//   - ctx context.Context
//   - cardUUID string
func (_e *MockMetabaseDataGetter_Expecter) GetDataMap(ctx interface{}, cardUUID interface{}) *MockMetabaseDataGetter_GetDataMap_Call {
	return &MockMetabaseDataGetter_GetDataMap_Call{Call: _e.mock.On("GetDataMap", ctx, cardUUID)}
}

func (_c *MockMetabaseDataGetter_GetDataMap_Call) Run(run func(ctx context.Context, cardUUID string)) *MockMetabaseDataGetter_GetDataMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetabaseDataGetter_GetDataMap_Call) Return(stringToVs []map[string]any, err error) *MockMetabaseDataGetter_GetDataMap_Call {
	_c.Call.Return(stringToVs, err)
	return _c
}

func (_c *MockMetabaseDataGetter_GetDataMap_Call) RunAndReturn(run func(ctx context.Context, cardUUID string) ([]map[string]any, error)) *MockMetabaseDataGetter_GetDataMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetDataMatrix provides a mock function for the type MockMetabaseDataGetter
func (_mock *MockMetabaseDataGetter) GetDataMatrix(ctx context.Context, cardUUID string) ([][]string, error) {
	ret := _mock.Called(ctx, cardUUID)

	if len(ret) == 0 {
		panic("no return value specified for GetDataMatrix")
	}

	var r0 [][]string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([][]string, error)); ok {
		return returnFunc(ctx, cardUUID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) [][]string); ok {
		r0 = returnFunc(ctx, cardUUID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, cardUUID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetabaseDataGetter_GetDataMatrix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDataMatrix'
type MockMetabaseDataGetter_GetDataMatrix_Call struct {
	*mock.Call
}

// GetDataMatrix is a helper method to define mock.On call
//   - ctx context.Context
//   - cardUUID string
func (_e *MockMetabaseDataGetter_Expecter) GetDataMatrix(ctx interface{}, cardUUID interface{}) *MockMetabaseDataGetter_GetDataMatrix_Call {
	return &MockMetabaseDataGetter_GetDataMatrix_Call{Call: _e.mock.On("GetDataMatrix", ctx, cardUUID)}
}

func (_c *MockMetabaseDataGetter_GetDataMatrix_Call) Run(run func(ctx context.Context, cardUUID string)) *MockMetabaseDataGetter_GetDataMatrix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMetabaseDataGetter_GetDataMatrix_Call) Return(stringss [][]string, err error) *MockMetabaseDataGetter_GetDataMatrix_Call {
	_c.Call.Return(stringss, err)
	return _c
}

func (_c *MockMetabaseDataGetter_GetDataMatrix_Call) RunAndReturn(run func(ctx context.Context, cardUUID string) ([][]string, error)) *MockMetabaseDataGetter_GetDataMatrix_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSender creates a new instance of MockSender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSender(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSender {
	mock := &MockSender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSender is an autogenerated mock type for the Sender type
type MockSender struct {
	mock.Mock
}

type MockSender_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSender) EXPECT() *MockSender_Expecter {
	return &MockSender_Expecter{mock: &_m.Mock}
}

// Send provides a mock function for the type MockSender
func (_mock *MockSender) Send(meta models.Targeted, data models.Sendable) error {
	ret := _mock.Called(meta, data)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(models.Targeted, models.Sendable) error); ok {
		r0 = returnFunc(meta, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockSender_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockSender_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - meta models.Targeted
//   - data models.Sendable
func (_e *MockSender_Expecter) Send(meta interface{}, data interface{}) *MockSender_Send_Call {
	return &MockSender_Send_Call{Call: _e.mock.On("Send", meta, data)}
}

func (_c *MockSender_Send_Call) Run(run func(meta models.Targeted, data models.Sendable)) *MockSender_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 models.Targeted
		if args[0] != nil {
			arg0 = args[0].(models.Targeted)
		}
		var arg1 models.Sendable
		if args[1] != nil {
			arg1 = args[1].(models.Sendable)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSender_Send_Call) Return(err error) *MockSender_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSender_Send_Call) RunAndReturn(run func(meta models.Targeted, data models.Sendable) error) *MockSender_Send_Call {
	_c.Call.Return(run)
	return _c
}

// newMocktelegramChatSender creates a new instance of mocktelegramChatSender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMocktelegramChatSender(t interface {
	mock.TestingT
	Cleanup(func())
}) *mocktelegramChatSender {
	mock := &mocktelegramChatSender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mocktelegramChatSender is an autogenerated mock type for the telegramChatSender type
type mocktelegramChatSender struct {
	mock.Mock
}

type mocktelegramChatSender_Expecter struct {
	mock *mock.Mock
}

func (_m *mocktelegramChatSender) EXPECT() *mocktelegramChatSender_Expecter {
	return &mocktelegramChatSender_Expecter{mock: &_m.Mock}
}

// Send provides a mock function for the type mocktelegramChatSender
func (_mock *mocktelegramChatSender) Send(chat models.TargetTelegramChat, msg models.TextData) error {
	ret := _mock.Called(chat, msg)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(models.TargetTelegramChat, models.TextData) error); ok {
		r0 = returnFunc(chat, msg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mocktelegramChatSender_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type mocktelegramChatSender_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - chat models.TargetTelegramChat
//   - msg models.TextData
func (_e *mocktelegramChatSender_Expecter) Send(chat interface{}, msg interface{}) *mocktelegramChatSender_Send_Call {
	return &mocktelegramChatSender_Send_Call{Call: _e.mock.On("Send", chat, msg)}
}

func (_c *mocktelegramChatSender_Send_Call) Run(run func(chat models.TargetTelegramChat, msg models.TextData)) *mocktelegramChatSender_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 models.TargetTelegramChat
		if args[0] != nil {
			arg0 = args[0].(models.TargetTelegramChat)
		}
		var arg1 models.TextData
		if args[1] != nil {
			arg1 = args[1].(models.TextData)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mocktelegramChatSender_Send_Call) Return(err error) *mocktelegramChatSender_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mocktelegramChatSender_Send_Call) RunAndReturn(run func(chat models.TargetTelegramChat, msg models.TextData) error) *mocktelegramChatSender_Send_Call {
	_c.Call.Return(run)
	return _c
}

// SendDocument provides a mock function for the type mocktelegramChatSender
func (_mock *mocktelegramChatSender) SendDocument(chat models.TargetTelegramChat, doc models.FileData) error {
	ret := _mock.Called(chat, doc)

	if len(ret) == 0 {
		panic("no return value specified for SendDocument")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(models.TargetTelegramChat, models.FileData) error); ok {
		r0 = returnFunc(chat, doc)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mocktelegramChatSender_SendDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendDocument'
type mocktelegramChatSender_SendDocument_Call struct {
	*mock.Call
}

// SendDocument is a helper method to define mock.On call
//   - chat models.TargetTelegramChat
//   - doc models.FileData
func (_e *mocktelegramChatSender_Expecter) SendDocument(chat interface{}, doc interface{}) *mocktelegramChatSender_SendDocument_Call {
	return &mocktelegramChatSender_SendDocument_Call{Call: _e.mock.On("SendDocument", chat, doc)}
}

func (_c *mocktelegramChatSender_SendDocument_Call) Run(run func(chat models.TargetTelegramChat, doc models.FileData)) *mocktelegramChatSender_SendDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 models.TargetTelegramChat
		if args[0] != nil {
			arg0 = args[0].(models.TargetTelegramChat)
		}
		var arg1 models.FileData
		if args[1] != nil {
			arg1 = args[1].(models.FileData)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mocktelegramChatSender_SendDocument_Call) Return(err error) *mocktelegramChatSender_SendDocument_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mocktelegramChatSender_SendDocument_Call) RunAndReturn(run func(chat models.TargetTelegramChat, doc models.FileData) error) *mocktelegramChatSender_SendDocument_Call {
	_c.Call.Return(run)
	return _c
}

// SendMedia provides a mock function for the type mocktelegramChatSender
func (_mock *mocktelegramChatSender) SendMedia(chat models.TargetTelegramChat, imgs models.ImageData) error {
	ret := _mock.Called(chat, imgs)

	if len(ret) == 0 {
		panic("no return value specified for SendMedia")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(models.TargetTelegramChat, models.ImageData) error); ok {
		r0 = returnFunc(chat, imgs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mocktelegramChatSender_SendMedia_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendMedia'
type mocktelegramChatSender_SendMedia_Call struct {
	*mock.Call
}

// SendMedia is a helper method to define mock.On call
//   - chat models.TargetTelegramChat
//   - imgs models.ImageData
func (_e *mocktelegramChatSender_Expecter) SendMedia(chat interface{}, imgs interface{}) *mocktelegramChatSender_SendMedia_Call {
	return &mocktelegramChatSender_SendMedia_Call{Call: _e.mock.On("SendMedia", chat, imgs)}
}

func (_c *mocktelegramChatSender_SendMedia_Call) Run(run func(chat models.TargetTelegramChat, imgs models.ImageData)) *mocktelegramChatSender_SendMedia_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 models.TargetTelegramChat
		if args[0] != nil {
			arg0 = args[0].(models.TargetTelegramChat)
		}
		var arg1 models.ImageData
		if args[1] != nil {
			arg1 = args[1].(models.ImageData)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mocktelegramChatSender_SendMedia_Call) Return(err error) *mocktelegramChatSender_SendMedia_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mocktelegramChatSender_SendMedia_Call) RunAndReturn(run func(chat models.TargetTelegramChat, imgs models.ImageData) error) *mocktelegramChatSender_SendMedia_Call {
	_c.Call.Return(run)
	return _c
}

// newMockfileUploader creates a new instance of mockfileUploader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockfileUploader(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockfileUploader {
	mock := &mockfileUploader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockfileUploader is an autogenerated mock type for the fileUploader type
type mockfileUploader struct {
	mock.Mock
}

type mockfileUploader_Expecter struct {
	mock *mock.Mock
}

func (_m *mockfileUploader) EXPECT() *mockfileUploader_Expecter {
	return &mockfileUploader_Expecter{mock: &_m.Mock}
}

// Upload provides a mock function for the type mockfileUploader
func (_mock *mockfileUploader) Upload(remote string, file *models.FileData) error {
	ret := _mock.Called(remote, file)

	if len(ret) == 0 {
		panic("no return value specified for Upload")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, *models.FileData) error); ok {
		r0 = returnFunc(remote, file)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mockfileUploader_Upload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upload'
type mockfileUploader_Upload_Call struct {
	*mock.Call
}

// Upload is a helper method to define mock.On call
//   - remote string
//   - file *models.FileData
func (_e *mockfileUploader_Expecter) Upload(remote interface{}, file interface{}) *mockfileUploader_Upload_Call {
	return &mockfileUploader_Upload_Call{Call: _e.mock.On("Upload", remote, file)}
}

func (_c *mockfileUploader_Upload_Call) Run(run func(remote string, file *models.FileData)) *mockfileUploader_Upload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *models.FileData
		if args[1] != nil {
			arg1 = args[1].(*models.FileData)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockfileUploader_Upload_Call) Return(err error) *mockfileUploader_Upload_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mockfileUploader_Upload_Call) RunAndReturn(run func(remote string, file *models.FileData) error) *mockfileUploader_Upload_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserGetter creates a new instance of MockUserGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserGetter {
	mock := &MockUserGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserGetter is an autogenerated mock type for the UserGetter type
type MockUserGetter struct {
	mock.Mock
}

type MockUserGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserGetter) EXPECT() *MockUserGetter_Expecter {
	return &MockUserGetter_Expecter{mock: &_m.Mock}
}

// GetAll provides a mock function for the type MockUserGetter
func (_mock *MockUserGetter) GetAll(ctx context.Context) ([]models.User, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAll")
	}

	var r0 []models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.User, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.User); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserGetter_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockUserGetter_GetAll_Call struct {
	*mock.Call
}

// GetAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUserGetter_Expecter) GetAll(ctx interface{}) *MockUserGetter_GetAll_Call {
	return &MockUserGetter_GetAll_Call{Call: _e.mock.On("GetAll", ctx)}
}

func (_c *MockUserGetter_GetAll_Call) Run(run func(ctx context.Context)) *MockUserGetter_GetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUserGetter_GetAll_Call) Return(users []models.User, err error) *MockUserGetter_GetAll_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *MockUserGetter_GetAll_Call) RunAndReturn(run func(ctx context.Context) ([]models.User, error)) *MockUserGetter_GetAll_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllAdmins provides a mock function for the type MockUserGetter
func (_mock *MockUserGetter) GetAllAdmins(ctx context.Context) ([]models.User, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllAdmins")
	}

	var r0 []models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.User, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.User); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserGetter_GetAllAdmins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllAdmins'
type MockUserGetter_GetAllAdmins_Call struct {
	*mock.Call
}

// GetAllAdmins is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUserGetter_Expecter) GetAllAdmins(ctx interface{}) *MockUserGetter_GetAllAdmins_Call {
	return &MockUserGetter_GetAllAdmins_Call{Call: _e.mock.On("GetAllAdmins", ctx)}
}

func (_c *MockUserGetter_GetAllAdmins_Call) Run(run func(ctx context.Context)) *MockUserGetter_GetAllAdmins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUserGetter_GetAllAdmins_Call) Return(users []models.User, err error) *MockUserGetter_GetAllAdmins_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *MockUserGetter_GetAllAdmins_Call) RunAndReturn(run func(ctx context.Context) ([]models.User, error)) *MockUserGetter_GetAllAdmins_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockActiveChatGetter creates a new instance of MockActiveChatGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockActiveChatGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockActiveChatGetter {
	mock := &MockActiveChatGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockActiveChatGetter is an autogenerated mock type for the ActiveChatGetter type
type MockActiveChatGetter struct {
	mock.Mock
}

type MockActiveChatGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockActiveChatGetter) EXPECT() *MockActiveChatGetter_Expecter {
	return &MockActiveChatGetter_Expecter{mock: &_m.Mock}
}

// GetAllActive provides a mock function for the type MockActiveChatGetter
func (_mock *MockActiveChatGetter) GetAllActive(ctx context.Context) ([]models.Chat, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllActive")
	}

	var r0 []models.Chat
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.Chat, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.Chat); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Chat)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockActiveChatGetter_GetAllActive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllActive'
type MockActiveChatGetter_GetAllActive_Call struct {
	*mock.Call
}

// GetAllActive is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockActiveChatGetter_Expecter) GetAllActive(ctx interface{}) *MockActiveChatGetter_GetAllActive_Call {
	return &MockActiveChatGetter_GetAllActive_Call{Call: _e.mock.On("GetAllActive", ctx)}
}

func (_c *MockActiveChatGetter_GetAllActive_Call) Run(run func(ctx context.Context)) *MockActiveChatGetter_GetAllActive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockActiveChatGetter_GetAllActive_Call) Return(chats []models.Chat, err error) *MockActiveChatGetter_GetAllActive_Call {
	_c.Call.Return(chats, err)
	return _c
}

func (_c *MockActiveChatGetter_GetAllActive_Call) RunAndReturn(run func(ctx context.Context) ([]models.Chat, error)) *MockActiveChatGetter_GetAllActive_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserProvider creates a new instance of MockUserProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserProvider {
	mock := &MockUserProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserProvider is an autogenerated mock type for the UserProvider type
type MockUserProvider struct {
	mock.Mock
}

type MockUserProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserProvider) EXPECT() *MockUserProvider_Expecter {
	return &MockUserProvider_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockUserProvider
func (_mock *MockUserProvider) Create(ctx context.Context, user *models.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserProvider_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserProvider_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *MockUserProvider_Expecter) Create(ctx interface{}, user interface{}) *MockUserProvider_Create_Call {
	return &MockUserProvider_Create_Call{Call: _e.mock.On("Create", ctx, user)}
}

func (_c *MockUserProvider_Create_Call) Run(run func(ctx context.Context, user *models.User)) *MockUserProvider_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.User
		if args[1] != nil {
			arg1 = args[1].(*models.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserProvider_Create_Call) Return(err error) *MockUserProvider_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserProvider_Create_Call) RunAndReturn(run func(ctx context.Context, user *models.User) error) *MockUserProvider_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockUserProvider
func (_mock *MockUserProvider) Delete(ctx context.Context, tgID int64) error {
	ret := _mock.Called(ctx, tgID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, tgID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserProvider_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockUserProvider_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - tgID int64
func (_e *MockUserProvider_Expecter) Delete(ctx interface{}, tgID interface{}) *MockUserProvider_Delete_Call {
	return &MockUserProvider_Delete_Call{Call: _e.mock.On("Delete", ctx, tgID)}
}

func (_c *MockUserProvider_Delete_Call) Run(run func(ctx context.Context, tgID int64)) *MockUserProvider_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserProvider_Delete_Call) Return(err error) *MockUserProvider_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserProvider_Delete_Call) RunAndReturn(run func(ctx context.Context, tgID int64) error) *MockUserProvider_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// GetAll provides a mock function for the type MockUserProvider
func (_mock *MockUserProvider) GetAll(ctx context.Context) ([]models.User, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAll")
	}

	var r0 []models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.User, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.User); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserProvider_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockUserProvider_GetAll_Call struct {
	*mock.Call
}

// GetAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUserProvider_Expecter) GetAll(ctx interface{}) *MockUserProvider_GetAll_Call {
	return &MockUserProvider_GetAll_Call{Call: _e.mock.On("GetAll", ctx)}
}

func (_c *MockUserProvider_GetAll_Call) Run(run func(ctx context.Context)) *MockUserProvider_GetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUserProvider_GetAll_Call) Return(users []models.User, err error) *MockUserProvider_GetAll_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *MockUserProvider_GetAll_Call) RunAndReturn(run func(ctx context.Context) ([]models.User, error)) *MockUserProvider_GetAll_Call {
	_c.Call.Return(run)
	return _c
}

// GetByTgID provides a mock function for the type MockUserProvider
func (_mock *MockUserProvider) GetByTgID(ctx context.Context, id int64) (*models.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByTgID")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*models.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *models.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserProvider_GetByTgID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByTgID'
type MockUserProvider_GetByTgID_Call struct {
	*mock.Call
}

// GetByTgID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockUserProvider_Expecter) GetByTgID(ctx interface{}, id interface{}) *MockUserProvider_GetByTgID_Call {
	return &MockUserProvider_GetByTgID_Call{Call: _e.mock.On("GetByTgID", ctx, id)}
}

func (_c *MockUserProvider_GetByTgID_Call) Run(run func(ctx context.Context, id int64)) *MockUserProvider_GetByTgID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserProvider_GetByTgID_Call) Return(user *models.User, err error) *MockUserProvider_GetByTgID_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserProvider_GetByTgID_Call) RunAndReturn(run func(ctx context.Context, id int64) (*models.User, error)) *MockUserProvider_GetByTgID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUsername provides a mock function for the type MockUserProvider
func (_mock *MockUserProvider) GetByUsername(ctx context.Context, username string) (*models.User, error) {
	ret := _mock.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for GetByUsername")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return returnFunc(ctx, username)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = returnFunc(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, username)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserProvider_GetByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUsername'
type MockUserProvider_GetByUsername_Call struct {
	*mock.Call
}

// GetByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockUserProvider_Expecter) GetByUsername(ctx interface{}, username interface{}) *MockUserProvider_GetByUsername_Call {
	return &MockUserProvider_GetByUsername_Call{Call: _e.mock.On("GetByUsername", ctx, username)}
}

func (_c *MockUserProvider_GetByUsername_Call) Run(run func(ctx context.Context, username string)) *MockUserProvider_GetByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserProvider_GetByUsername_Call) Return(user *models.User, err error) *MockUserProvider_GetByUsername_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserProvider_GetByUsername_Call) RunAndReturn(run func(ctx context.Context, username string) (*models.User, error)) *MockUserProvider_GetByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockUserProvider
func (_mock *MockUserProvider) Update(ctx context.Context, user *models.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserProvider_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockUserProvider_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *MockUserProvider_Expecter) Update(ctx interface{}, user interface{}) *MockUserProvider_Update_Call {
	return &MockUserProvider_Update_Call{Call: _e.mock.On("Update", ctx, user)}
}

func (_c *MockUserProvider_Update_Call) Run(run func(ctx context.Context, user *models.User)) *MockUserProvider_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.User
		if args[1] != nil {
			arg1 = args[1].(*models.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserProvider_Update_Call) Return(err error) *MockUserProvider_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserProvider_Update_Call) RunAndReturn(run func(ctx context.Context, user *models.User) error) *MockUserProvider_Update_Call {
	_c.Call.Return(run)
	return _c
}
