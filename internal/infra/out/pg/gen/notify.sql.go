// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notify.sql

package repogen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listAllActiveNotifies = `-- name: ListAllActiveNotifies :many
SELECT
    n.id,
    n.name,
    ng.name  AS group_id,
array_agg(DISTINCT nq.card_uuid)::text[] AS card_uuids,
    n.cron,
    tp.template_text,
    n.title,
    ng.title AS group_title,
    c.chat_id,
    n.remote_path,
    n.active,
    n.format,
    n.thread_id
FROM notify n
LEFT JOIN chats c ON n.chat_id = c.id
LEFT JOIN notify_groups ng ON n.group_id = ng.id
LEFT JOIN notify_queries nqj ON nqj.notify_id = n.id
LEFT JOIN queries nq ON nq.id = nqj.query_id
LEFT JOIN templates tp ON tp.id = n.template_id
WHERE n.active = TRUE
GROUP BY n.id, n.name, ng.name, n.cron, tp.template_text,
         n.title, ng.title, c.chat_id, n.remote_path,
         n.active, n.format, n.thread_id
ORDER BY n.id
`

type ListAllActiveNotifiesRow struct {
	ID           int32
	Name         string
	GroupID      pgtype.Text
	CardUuids    []string
	Cron         string
	TemplateText pgtype.Text
	Title        string
	GroupTitle   pgtype.Text
	ChatID       pgtype.Int8
	RemotePath   pgtype.Text
	Active       bool
	Format       []string
	ThreadID     int64
}

func (q *Queries) ListAllActiveNotifies(ctx context.Context) ([]ListAllActiveNotifiesRow, error) {
	rows, err := q.db.Query(ctx, listAllActiveNotifies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllActiveNotifiesRow
	for rows.Next() {
		var i ListAllActiveNotifiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.GroupID,
			&i.CardUuids,
			&i.Cron,
			&i.TemplateText,
			&i.Title,
			&i.GroupTitle,
			&i.ChatID,
			&i.RemotePath,
			&i.Active,
			&i.Format,
			&i.ThreadID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllNotifies = `-- name: ListAllNotifies :many
SELECT
    n.id,
    n.name,
    ng.name  AS group_id,
array_agg(DISTINCT nq.card_uuid)::text[] AS card_uuids,
    n.cron,
    tp.template_text,
    n.title,
    ng.title AS group_title,
    n.remote_path,
    c.chat_id,
    n.active,
    n.format,
    n.thread_id
FROM notify n
LEFT JOIN chats c ON n.chat_id = c.id
LEFT JOIN notify_groups ng ON n.group_id = ng.id
LEFT JOIN notify_queries nqj ON nqj.notify_id = n.id
LEFT JOIN queries nq ON nq.id = nqj.query_id
LEFT JOIN templates tp ON tp.id = n.template_id
GROUP BY n.id, n.name, ng.name, n.cron, tp.template_text,
         n.title, ng.title, n.remote_path, c.chat_id,
         n.active, n.format, n.thread_id
ORDER BY n.id
`

type ListAllNotifiesRow struct {
	ID           int32
	Name         string
	GroupID      pgtype.Text
	CardUuids    []string
	Cron         string
	TemplateText pgtype.Text
	Title        string
	GroupTitle   pgtype.Text
	RemotePath   pgtype.Text
	ChatID       pgtype.Int8
	Active       bool
	Format       []string
	ThreadID     int64
}

func (q *Queries) ListAllNotifies(ctx context.Context) ([]ListAllNotifiesRow, error) {
	rows, err := q.db.Query(ctx, listAllNotifies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllNotifiesRow
	for rows.Next() {
		var i ListAllNotifiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.GroupID,
			&i.CardUuids,
			&i.Cron,
			&i.TemplateText,
			&i.Title,
			&i.GroupTitle,
			&i.RemotePath,
			&i.ChatID,
			&i.Active,
			&i.Format,
			&i.ThreadID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
