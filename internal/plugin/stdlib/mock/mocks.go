// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package stdlib_mock

import (
	"context"
	"support_bot/internal/delivery/smtp"
	"support_bot/internal/models/report"

	mock "github.com/stretchr/testify/mock"
)

// NewMockCollector creates a new instance of MockCollector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCollector(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCollector {
	mock := &MockCollector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCollector is an autogenerated mock type for the Collector type
type MockCollector struct {
	mock.Mock
}

type MockCollector_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCollector) EXPECT() *MockCollector_Expecter {
	return &MockCollector_Expecter{mock: &_m.Mock}
}

// Collect provides a mock function for the type MockCollector
func (_mock *MockCollector) Collect(ctx context.Context, cards ...models.Card) (map[string][]map[string]any, error) {
	var tmpRet mock.Arguments
	if len(cards) > 0 {
		tmpRet = _mock.Called(ctx, cards)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Collect")
	}

	var r0 map[string][]map[string]any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...models.Card) (map[string][]map[string]any, error)); ok {
		return returnFunc(ctx, cards...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...models.Card) map[string][]map[string]any); ok {
		r0 = returnFunc(ctx, cards...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]map[string]any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ...models.Card) error); ok {
		r1 = returnFunc(ctx, cards...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCollector_Collect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Collect'
type MockCollector_Collect_Call struct {
	*mock.Call
}

// Collect is a helper method to define mock.On call
//   - ctx context.Context
//   - cards ...models.Card
func (_e *MockCollector_Expecter) Collect(ctx interface{}, cards ...interface{}) *MockCollector_Collect_Call {
	return &MockCollector_Collect_Call{Call: _e.mock.On("Collect",
		append([]interface{}{ctx}, cards...)...)}
}

func (_c *MockCollector_Collect_Call) Run(run func(ctx context.Context, cards ...models.Card)) *MockCollector_Collect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []models.Card
		var variadicArgs []models.Card
		if len(args) > 1 {
			variadicArgs = args[1].([]models.Card)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockCollector_Collect_Call) Return(stringToStringToVs map[string][]map[string]any, err error) *MockCollector_Collect_Call {
	_c.Call.Return(stringToStringToVs, err)
	return _c
}

func (_c *MockCollector_Collect_Call) RunAndReturn(run func(ctx context.Context, cards ...models.Card) (map[string][]map[string]any, error)) *MockCollector_Collect_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTelegramChatSender creates a new instance of MockTelegramChatSender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTelegramChatSender(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTelegramChatSender {
	mock := &MockTelegramChatSender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTelegramChatSender is an autogenerated mock type for the TelegramChatSender type
type MockTelegramChatSender struct {
	mock.Mock
}

type MockTelegramChatSender_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTelegramChatSender) EXPECT() *MockTelegramChatSender_Expecter {
	return &MockTelegramChatSender_Expecter{mock: &_m.Mock}
}

// Send provides a mock function for the type MockTelegramChatSender
func (_mock *MockTelegramChatSender) Send(ctx context.Context, chat models.TargetTelegramChat, data ...models.ReportData) error {
	var tmpRet mock.Arguments
	if len(data) > 0 {
		tmpRet = _mock.Called(ctx, chat, data)
	} else {
		tmpRet = _mock.Called(ctx, chat)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.TargetTelegramChat, ...models.ReportData) error); ok {
		r0 = returnFunc(ctx, chat, data...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTelegramChatSender_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockTelegramChatSender_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - ctx context.Context
//   - chat models.TargetTelegramChat
//   - data ...models.ReportData
func (_e *MockTelegramChatSender_Expecter) Send(ctx interface{}, chat interface{}, data ...interface{}) *MockTelegramChatSender_Send_Call {
	return &MockTelegramChatSender_Send_Call{Call: _e.mock.On("Send",
		append([]interface{}{ctx, chat}, data...)...)}
}

func (_c *MockTelegramChatSender_Send_Call) Run(run func(ctx context.Context, chat models.TargetTelegramChat, data ...models.ReportData)) *MockTelegramChatSender_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.TargetTelegramChat
		if args[1] != nil {
			arg1 = args[1].(models.TargetTelegramChat)
		}
		var arg2 []models.ReportData
		var variadicArgs []models.ReportData
		if len(args) > 2 {
			variadicArgs = args[2].([]models.ReportData)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTelegramChatSender_Send_Call) Return(err error) *MockTelegramChatSender_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTelegramChatSender_Send_Call) RunAndReturn(run func(ctx context.Context, chat models.TargetTelegramChat, data ...models.ReportData) error) *MockTelegramChatSender_Send_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockFileUploader creates a new instance of MockFileUploader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFileUploader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFileUploader {
	mock := &MockFileUploader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockFileUploader is an autogenerated mock type for the FileUploader type
type MockFileUploader struct {
	mock.Mock
}

type MockFileUploader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockFileUploader) EXPECT() *MockFileUploader_Expecter {
	return &MockFileUploader_Expecter{mock: &_m.Mock}
}

// Upload provides a mock function for the type MockFileUploader
func (_mock *MockFileUploader) Upload(ctx context.Context, remote string, fileData ...models.ReportData) error {
	var tmpRet mock.Arguments
	if len(fileData) > 0 {
		tmpRet = _mock.Called(ctx, remote, fileData)
	} else {
		tmpRet = _mock.Called(ctx, remote)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Upload")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...models.ReportData) error); ok {
		r0 = returnFunc(ctx, remote, fileData...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockFileUploader_Upload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upload'
type MockFileUploader_Upload_Call struct {
	*mock.Call
}

// Upload is a helper method to define mock.On call
//   - ctx context.Context
//   - remote string
//   - fileData ...models.ReportData
func (_e *MockFileUploader_Expecter) Upload(ctx interface{}, remote interface{}, fileData ...interface{}) *MockFileUploader_Upload_Call {
	return &MockFileUploader_Upload_Call{Call: _e.mock.On("Upload",
		append([]interface{}{ctx, remote}, fileData...)...)}
}

func (_c *MockFileUploader_Upload_Call) Run(run func(ctx context.Context, remote string, fileData ...models.ReportData)) *MockFileUploader_Upload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []models.ReportData
		var variadicArgs []models.ReportData
		if len(args) > 2 {
			variadicArgs = args[2].([]models.ReportData)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockFileUploader_Upload_Call) Return(err error) *MockFileUploader_Upload_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockFileUploader_Upload_Call) RunAndReturn(run func(ctx context.Context, remote string, fileData ...models.ReportData) error) *MockFileUploader_Upload_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSMTPSender creates a new instance of MockSMTPSender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSMTPSender(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSMTPSender {
	mock := &MockSMTPSender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSMTPSender is an autogenerated mock type for the SMTPSender type
type MockSMTPSender struct {
	mock.Mock
}

type MockSMTPSender_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSMTPSender) EXPECT() *MockSMTPSender_Expecter {
	return &MockSMTPSender_Expecter{mock: &_m.Mock}
}

// Send provides a mock function for the type MockSMTPSender
func (_mock *MockSMTPSender) Send(ctx context.Context, mail smtp.Mail) error {
	ret := _mock.Called(ctx, mail)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, smtp.Mail) error); ok {
		r0 = returnFunc(ctx, mail)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockSMTPSender_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockSMTPSender_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - ctx context.Context
//   - mail smtp.Mail
func (_e *MockSMTPSender_Expecter) Send(ctx interface{}, mail interface{}) *MockSMTPSender_Send_Call {
	return &MockSMTPSender_Send_Call{Call: _e.mock.On("Send", ctx, mail)}
}

func (_c *MockSMTPSender_Send_Call) Run(run func(ctx context.Context, mail smtp.Mail)) *MockSMTPSender_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 smtp.Mail
		if args[1] != nil {
			arg1 = args[1].(smtp.Mail)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSMTPSender_Send_Call) Return(err error) *MockSMTPSender_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSMTPSender_Send_Call) RunAndReturn(run func(ctx context.Context, mail smtp.Mail) error) *MockSMTPSender_Send_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSender creates a new instance of MockSender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSender(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSender {
	mock := &MockSender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSender is an autogenerated mock type for the Sender type
type MockSender struct {
	mock.Mock
}

type MockSender_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSender) EXPECT() *MockSender_Expecter {
	return &MockSender_Expecter{mock: &_m.Mock}
}

// Send provides a mock function for the type MockSender
func (_mock *MockSender) Send(ctx context.Context, metas []models.Targeted, data []models.ReportData) error {
	ret := _mock.Called(ctx, metas, data)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []models.Targeted, []models.ReportData) error); ok {
		r0 = returnFunc(ctx, metas, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockSender_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockSender_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - ctx context.Context
//   - metas []models.Targeted
//   - data []models.ReportData
func (_e *MockSender_Expecter) Send(ctx interface{}, metas interface{}, data interface{}) *MockSender_Send_Call {
	return &MockSender_Send_Call{Call: _e.mock.On("Send", ctx, metas, data)}
}

func (_c *MockSender_Send_Call) Run(run func(ctx context.Context, metas []models.Targeted, data []models.ReportData)) *MockSender_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []models.Targeted
		if args[1] != nil {
			arg1 = args[1].([]models.Targeted)
		}
		var arg2 []models.ReportData
		if args[2] != nil {
			arg2 = args[2].([]models.ReportData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSender_Send_Call) Return(err error) *MockSender_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSender_Send_Call) RunAndReturn(run func(ctx context.Context, metas []models.Targeted, data []models.ReportData) error) *MockSender_Send_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEvaluator creates a new instance of MockEvaluator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEvaluator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEvaluator {
	mock := &MockEvaluator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEvaluator is an autogenerated mock type for the Evaluator type
type MockEvaluator struct {
	mock.Mock
}

type MockEvaluator_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEvaluator) EXPECT() *MockEvaluator_Expecter {
	return &MockEvaluator_Expecter{mock: &_m.Mock}
}

// Evaluate provides a mock function for the type MockEvaluator
func (_mock *MockEvaluator) Evaluate(ctx context.Context, data map[string][]map[string]any, expr string) (bool, error) {
	ret := _mock.Called(ctx, data, expr)

	if len(ret) == 0 {
		panic("no return value specified for Evaluate")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, map[string][]map[string]any, string) (bool, error)); ok {
		return returnFunc(ctx, data, expr)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, map[string][]map[string]any, string) bool); ok {
		r0 = returnFunc(ctx, data, expr)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, map[string][]map[string]any, string) error); ok {
		r1 = returnFunc(ctx, data, expr)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEvaluator_Evaluate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Evaluate'
type MockEvaluator_Evaluate_Call struct {
	*mock.Call
}

// Evaluate is a helper method to define mock.On call
//   - ctx context.Context
//   - data map[string][]map[string]any
//   - expr string
func (_e *MockEvaluator_Expecter) Evaluate(ctx interface{}, data interface{}, expr interface{}) *MockEvaluator_Evaluate_Call {
	return &MockEvaluator_Evaluate_Call{Call: _e.mock.On("Evaluate", ctx, data, expr)}
}

func (_c *MockEvaluator_Evaluate_Call) Run(run func(ctx context.Context, data map[string][]map[string]any, expr string)) *MockEvaluator_Evaluate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 map[string][]map[string]any
		if args[1] != nil {
			arg1 = args[1].(map[string][]map[string]any)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockEvaluator_Evaluate_Call) Return(b bool, err error) *MockEvaluator_Evaluate_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEvaluator_Evaluate_Call) RunAndReturn(run func(ctx context.Context, data map[string][]map[string]any, expr string) (bool, error)) *MockEvaluator_Evaluate_Call {
	_c.Call.Return(run)
	return _c
}
